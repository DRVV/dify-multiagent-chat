{"version":3,"sources":["/home/ns/Projects/Cline/alois/packages/DifyChatComponent/dist/index.js","../src/DifyChatComponent.tsx","../src/ChatWindow/index.tsx","#style-inject:#style-inject","../src/ChatWindow/ChatWindow.module.css","../src/components/ChatInput.tsx","../src/styles/DifyChatComponent.module.css","../src/hooks/useDifyStream.ts","../../../node_modules/eventsource-parser/src/errors.ts","../../../node_modules/eventsource-parser/src/parse.ts","../src/store/chatStore.ts"],"names":["jsx"],"mappings":"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","file":"/home/ns/Projects/Cline/alois/packages/DifyChatComponent/dist/index.js","sourcesContent":[null,"'use client';\n\nimport React, { useMemo } from 'react';\nimport ChatWindow from './ChatWindow';\nimport { ChatInput } from './components/ChatInput';\nimport { useDifyStream } from './hooks/useDifyStream';\nimport { useChatStore } from './store/chatStore';\nimport { DifyChatComponentProps } from './types';\nimport { SpeakerConfig } from './ChatWindow/types';\nimport './styles/DifyChatComponent.module.css';\n\nconst DifyChatComponent: React.FC<DifyChatComponentProps> = ({\n  config,\n  className = '',\n  title = 'Dify Chat'\n}) => {\n  const { \n    messages, \n    isLoading \n  } = useChatStore();\n  \n  const { sendMessage } = useDifyStream(config);\n\n  // Default speakers for user and assistant\n  const speakers: SpeakerConfig[] = useMemo(() => [\n    { id: 'user', displayName: 'You', color: '#007bff' },\n    { id: 'assistant', displayName: 'Assistant', color: '#28a745' }\n  ], []);\n\n  const handleSendMessage = async (message: string) => {\n    // Add user message immediately\n    const userMessage = {\n      id: Date.now().toString(),\n      content: message,\n      timestamp: new Date(),\n      speaker: 'user',\n      speakerDisplayName: 'You'\n    };\n    \n    useChatStore.getState().addMessage(userMessage);\n    \n    // Send to Dify\n    await sendMessage(message);\n  };\n\n  // Now just use messages directly since streaming messages are added immediately\n  const displayMessages = useMemo(() => {\n    return [...messages];\n  }, [messages]);\n\n  return (\n    <div className={`container ${className}`}>\n      <div className={`chatWindowContainer`}>\n        <ChatWindow\n          messages={displayMessages}\n          speakers={speakers}\n          title={title}\n          showTimestamps={true}\n          showSpeakers={true}\n        />\n        {isLoading && (\n          <div className=\"streamingIndicator\">\n            Assistant is thinking...\n          </div>\n        )}\n      </div>\n      \n      <ChatInput\n        onSendMessage={handleSendMessage}\n        isLoading={isLoading}\n        placeholder=\"Ask me anything...\"\n      />\n    </div>\n  );\n};\n\nexport default DifyChatComponent;\nexport type { DifyChatComponentProps, DifyConfig } from './types';\n","'use client';\n\nimport React, { useMemo } from 'react';\nimport { ChatWindowProps, ChatMessage, SpeakerConfig } from './types';\nimport './ChatWindow.module.css';\n\nconst ChatWindow: React.FC<ChatWindowProps> = ({\n  messages,\n  speakers = [],\n  onExport,\n  className = '',\n  maxHeight = '400px',\n  showTimestamps = true,\n  showSpeakers = true,\n  title = 'Chat',\n}) => {\n  // Create speaker lookup for efficient access\n  const speakerMap = useMemo(() => {\n    const map = new Map<string, SpeakerConfig>();\n    speakers.forEach(speaker => {\n      map.set(speaker.id, speaker);\n    });\n    return map;\n  }, [speakers]);\n\n  // Format timestamp\n  const formatTimestamp = (timestamp: Date) => {\n    return new Intl.DateTimeFormat('en-US', {\n      hour: '2-digit',\n      minute: '2-digit',\n      hour12: true,\n    }).format(timestamp);\n  };\n\n  // Default export handler\n  const handleExport = () => {\n    if (onExport) {\n      onExport(messages);\n    } else {\n      // Built-in export functionality\n      const exportData = messages.map(msg => ({\n        timestamp: msg.timestamp.toISOString(),\n        speaker: msg.speaker,\n        speakerDisplayName: msg.speakerDisplayName,\n        content: msg.content,\n        duration: msg.duration,\n      }));\n\n      const dataStr = JSON.stringify(exportData, null, 2);\n      const dataBlob = new Blob([dataStr], { type: 'application/json' });\n      const url = URL.createObjectURL(dataBlob);\n      \n      const link = document.createElement('a');\n      link.href = url;\n      link.download = `chat-${new Date().toISOString().split('T')[0]}.json`;\n      document.body.appendChild(link);\n      link.click();\n      document.body.removeChild(link);\n      URL.revokeObjectURL(url);\n    }\n  };\n\n  return (\n    <div className={`container ${className}`}>\n      <div className=\"header\">\n        <h3 className=\"title\">{title}</h3>\n        <button\n          onClick={handleExport}\n          className=\"exportButton\"\n          disabled={messages.length === 0}\n          title=\"Export chat as JSON\"\n        >\n          Export\n        </button>\n      </div>\n\n      <div \n        className=\"messagesContainer\"\n        style={{ maxHeight }}\n      >\n        {messages.length === 0 ? (\n          <div className=\"emptyState\">\n            <div className=\"emptyIcon\">üí¨</div>\n            <div className=\"emptyText\">No messages yet</div>\n            <div className=\"emptySubtext\">Messages will appear here when sent</div>\n          </div>\n        ) : (\n          messages.map((message) => {\n            const speaker = speakerMap.get(message.speaker);\n            const displayName = message.speakerDisplayName || speaker?.displayName || message.speaker;\n            const speakerColor = speaker?.color || '#007bff';\n\n            return (\n              <div key={message.id} className=\"messageGroup\">\n                {showSpeakers && (\n                  <div className=\"messageHeader\">\n                    <span \n                      className=\"speakerName\"\n                      style={{ color: speakerColor }}\n                    >\n                      {displayName}\n                    </span>\n                    {showTimestamps && (\n                      <span className=\"timestamp\">\n                        {formatTimestamp(message.timestamp)}\n                      </span>\n                    )}\n                  </div>\n                )}\n                <div className=\"messageContent\">\n                  {message.content}\n                </div>\n              </div>\n            );\n          })\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default ChatWindow;\nexport type { ChatWindowProps, ChatMessage, SpeakerConfig };\n","\n          export default function styleInject(css, { insertAt } = {}) {\n            if (!css || typeof document === 'undefined') return\n          \n            const head = document.head || document.getElementsByTagName('head')[0]\n            const style = document.createElement('style')\n            style.type = 'text/css'\n          \n            if (insertAt === 'top') {\n              if (head.firstChild) {\n                head.insertBefore(style, head.firstChild)\n              } else {\n                head.appendChild(style)\n              }\n            } else {\n              head.appendChild(style)\n            }\n          \n            if (style.styleSheet) {\n              style.styleSheet.cssText = css\n            } else {\n              style.appendChild(document.createTextNode(css))\n            }\n          }\n          ","import styleInject from '#style-inject';styleInject(\".container {\\n  display: flex;\\n  flex-direction: column;\\n  background: #ffffff;\\n  border: 1px solid #e1e5e9;\\n  border-radius: 8px;\\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\\n  overflow: hidden;\\n}\\n.header {\\n  display: flex;\\n  justify-content: space-between;\\n  align-items: center;\\n  padding: 12px 16px;\\n  background: #f8f9fa;\\n  border-bottom: 1px solid #e1e5e9;\\n}\\n.title {\\n  font-size: 16px;\\n  font-weight: 600;\\n  color: #495057;\\n  margin: 0;\\n}\\n.exportButton {\\n  padding: 6px 12px;\\n  background: #007bff;\\n  color: white;\\n  border: none;\\n  border-radius: 4px;\\n  font-size: 12px;\\n  cursor: pointer;\\n  transition: background-color 0.2s;\\n}\\n.exportButton:hover:not(:disabled) {\\n  background: #0056b3;\\n}\\n.exportButton:disabled {\\n  background: #6c757d;\\n  cursor: not-allowed;\\n}\\n.messagesContainer {\\n  flex: 1;\\n  overflow-y: auto;\\n  padding: 16px;\\n  display: flex;\\n  flex-direction: column;\\n  gap: 12px;\\n  max-height: 400px;\\n}\\n.messageGroup {\\n  display: flex;\\n  flex-direction: column;\\n  gap: 4px;\\n}\\n.messageHeader {\\n  display: flex;\\n  align-items: center;\\n  gap: 8px;\\n  margin-bottom: 4px;\\n}\\n.speakerName {\\n  font-weight: 600;\\n  font-size: 14px;\\n  color: #007bff;\\n}\\n.timestamp {\\n  font-size: 12px;\\n  color: #6c757d;\\n}\\n.messageContent {\\n  background: #f8f9fa;\\n  padding: 8px 12px;\\n  border-radius: 12px;\\n  font-size: 14px;\\n  line-height: 1.4;\\n  color: #212529;\\n  word-wrap: break-word;\\n  max-width: 80%;\\n}\\n.emptyState {\\n  display: flex;\\n  flex-direction: column;\\n  align-items: center;\\n  justify-content: center;\\n  padding: 40px 20px;\\n  text-align: center;\\n  color: #6c757d;\\n}\\n.emptyIcon {\\n  font-size: 48px;\\n  margin-bottom: 12px;\\n  opacity: 0.5;\\n}\\n.emptyText {\\n  font-size: 16px;\\n  margin-bottom: 4px;\\n}\\n.emptySubtext {\\n  font-size: 14px;\\n  opacity: 0.7;\\n}\\n.messagesContainer::-webkit-scrollbar {\\n  width: 6px;\\n}\\n.messagesContainer::-webkit-scrollbar-track {\\n  background: #f1f1f1;\\n  border-radius: 3px;\\n}\\n.messagesContainer::-webkit-scrollbar-thumb {\\n  background: #c1c1c1;\\n  border-radius: 3px;\\n}\\n.messagesContainer::-webkit-scrollbar-thumb:hover {\\n  background: #a8a8a8;\\n}\\n\")","'use client';\n\nimport React, { useState, KeyboardEvent } from 'react';\nimport '../styles/DifyChatComponent.module.css';\n\ninterface ChatInputProps {\n  onSendMessage: (message: string) => void;\n  isLoading: boolean;\n  placeholder?: string;\n}\n\nexport const ChatInput: React.FC<ChatInputProps> = ({ \n  onSendMessage, \n  isLoading, \n  placeholder = \"Type your message...\" \n}) => {\n  const [message, setMessage] = useState('');\n\n  const handleSend = () => {\n    if (message.trim() && !isLoading) {\n      onSendMessage(message.trim());\n      setMessage('');\n    }\n  };\n\n  const handleKeyDown = (e: KeyboardEvent<HTMLTextAreaElement>) => {\n    if (e.key === 'Enter' && !e.shiftKey) {\n      e.preventDefault();\n      handleSend();\n    }\n  };\n\n  return (\n    <div className=\"inputContainer\">\n      <div className=\"inputWrapper\">\n        <textarea\n          value={message}\n          onChange={(e) => setMessage(e.target.value)}\n          onKeyDown={handleKeyDown}\n          placeholder={placeholder}\n          className=\"messageInput\"\n          rows={1}\n          disabled={isLoading}\n        />\n        <button\n          onClick={handleSend}\n          disabled={!message.trim() || isLoading}\n          className=\"sendButton\"\n          title=\"Send message\"\n        >\n          {isLoading ? '‚è≥' : '‚û§'}\n        </button>\n      </div>\n    </div>\n  );\n};\n","import styleInject from '#style-inject';styleInject(\".container {\\n  display: flex;\\n  flex-direction: column;\\n  height: 100%;\\n  max-width: 100%;\\n  background: #ffffff;\\n  border-radius: 8px;\\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\\n  overflow: hidden;\\n}\\n.chatWindowContainer {\\n  flex: 1;\\n  overflow: hidden;\\n}\\n.inputContainer {\\n  padding: 16px;\\n  border-top: 1px solid #e0e0e0;\\n  background: #f9f9f9;\\n}\\n.inputWrapper {\\n  display: flex;\\n  gap: 8px;\\n  align-items: flex-end;\\n}\\n.messageInput {\\n  flex: 1;\\n  min-height: 20px;\\n  max-height: 120px;\\n  padding: 12px 16px;\\n  border: 1px solid #d0d0d0;\\n  border-radius: 24px;\\n  font-family: inherit;\\n  font-size: 14px;\\n  line-height: 1.4;\\n  resize: none;\\n  outline: none;\\n  transition: border-color 0.2s ease;\\n}\\n.messageInput:focus {\\n  border-color: #007bff;\\n}\\n.messageInput:disabled {\\n  background-color: #f5f5f5;\\n  cursor: not-allowed;\\n}\\n.sendButton {\\n  display: flex;\\n  align-items: center;\\n  justify-content: center;\\n  width: 48px;\\n  height: 48px;\\n  background: #007bff;\\n  color: white;\\n  border: none;\\n  border-radius: 50%;\\n  cursor: pointer;\\n  font-size: 18px;\\n  transition: background-color 0.2s ease, transform 0.1s ease;\\n}\\n.sendButton:hover:not(:disabled) {\\n  background: #0056b3;\\n  transform: scale(1.05);\\n}\\n.sendButton:disabled {\\n  background: #ccc;\\n  cursor: not-allowed;\\n  transform: none;\\n}\\n.streamingIndicator {\\n  padding: 8px 16px;\\n  background: #f0f8ff;\\n  border-left: 4px solid #007bff;\\n  margin: 8px 16px;\\n  border-radius: 4px;\\n  font-size: 14px;\\n  color: #666;\\n  font-style: italic;\\n}\\n.streamingText {\\n  color: #333;\\n  font-style: normal;\\n}\\n\")","import { useCallback } from 'react';\nimport { createParser, EventSourceMessage } from 'eventsource-parser';\nimport { DifyConfig, DifySSEEvent, DifyRequestBody } from '../types';\nimport { useChatStore } from '../store/chatStore';\n\n\nexport const useDifyStream = (config: DifyConfig) => {\n  const { \n    setLoading, \n    appendStreamingMessage,\n    completeStreamingMessage,\n    conversationId,\n    setConversationId \n  } = useChatStore();\n\n  const sendMessage = useCallback(async (message: string) => {\n    setLoading(true);\n    // No need to clear streaming message since each chunk creates a new message\n    \n    try {\n      const requestBody: DifyRequestBody = {\n        inputs: {},\n        query: message,\n        response_mode: 'streaming',\n        conversation_id: conversationId,\n        user: config.user || 'user-001'\n      };\n\n      console.log(\"[useDifyStream] Start fetching for body \", requestBody);\n\n      const response = await fetch(`${config.endpoint}/v1/chat-messages`, {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${config.apiKey}`,\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(requestBody)\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      const reader = response.body?.getReader();\n      if (!reader) {\n        throw new Error('No response body reader available');\n      }\n\n      const decoder = new TextDecoder();\n      // let streamingText = '';\n\n      const parser = createParser({\n        onEvent: (ev: EventSourceMessage) => {\n//          console.log('[useDifyStream] onEvent: ', ev);\n\n          if (true || ev.event === 'message' || ev.event === 'node_finished' || ev.event === 'message_end' || ev.event === 'workflow_started' || ev.event === 'workflow_finished') {\n            try {\n              const eventData = JSON.parse(ev.data) as DifySSEEvent;\n\n              //console.log('[useDifyStream] eventData:', eventData);\n              \n              // Handle different event types\n              switch (eventData.event) {\n                // case 'message':\n                //   if (eventData.answer) {\n                //     streamingText += eventData.answer;\n                //     updateStreamingMessage(streamingText);\n                //   }\n                //   break;\n                  \n                case 'node_finished':\n                  // Primary event type for processing completion\n                  console.log('Node finished:', eventData);\n                  if (eventData.data?.outputs?.text) {\n                    const speaker = eventData.data.title;\n                    console.log(\"Speaker: \", speaker);\n                    // Create a new message entry for each streaming chunk\n                    appendStreamingMessage(eventData.data.outputs.text, speaker, speaker);\n                  }\n                  break;\n                  \n                case 'message_end':\n                  console.log('message_end:', eventData.event, eventData);  \n                \n                  completeStreamingMessage();\n                  if (eventData.conversation_id && eventData.conversation_id !== conversationId) {\n                    setConversationId(eventData.conversation_id);\n                  }\n                  break;\n                  \n                case 'workflow_started':\n                case 'workflow_finished':\n                  console.log('Workflow event:', eventData.event, eventData);\n                  break;\n              }\n            } catch (parseError) {\n              console.log('SSE parse error:', parseError);\n            }\n          }\n        }\n      });\n\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) break;\n\n        const chunk = decoder.decode(value, { stream: true });\n        parser.feed(chunk);\n      }\n    } catch (error) {\n      console.log('Dify API error:', error);\n    } finally {\n      setLoading(false);\n    }\n  }, [config, conversationId, setLoading, appendStreamingMessage, completeStreamingMessage, setConversationId]);\n\n  return { sendMessage };\n};\n","/**\n * The type of error that occurred.\n * @public\n */\nexport type ErrorType = 'invalid-retry' | 'unknown-field'\n\n/**\n * Error thrown when encountering an issue during parsing.\n *\n * @public\n */\nexport class ParseError extends Error {\n  /**\n   * The type of error that occurred.\n   */\n  type: ErrorType\n\n  /**\n   * In the case of an unknown field encountered in the stream, this will be the field name.\n   */\n  field?: string\n\n  /**\n   * In the case of an unknown field encountered in the stream, this will be the value of the field.\n   */\n  value?: string\n\n  /**\n   * The line that caused the error, if available.\n   */\n  line?: string\n\n  constructor(\n    message: string,\n    options: {type: ErrorType; field?: string; value?: string; line?: string},\n  ) {\n    super(message)\n    this.name = 'ParseError'\n    this.type = options.type\n    this.field = options.field\n    this.value = options.value\n    this.line = options.line\n  }\n}\n","/**\n * EventSource/Server-Sent Events parser\n * @see https://html.spec.whatwg.org/multipage/server-sent-events.html\n */\nimport {ParseError} from './errors.ts'\nimport type {EventSourceParser, ParserCallbacks} from './types.ts'\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction noop(_arg: unknown) {\n  // intentional noop\n}\n\n/**\n * Creates a new EventSource parser.\n *\n * @param callbacks - Callbacks to invoke on different parsing events:\n *   - `onEvent` when a new event is parsed\n *   - `onError` when an error occurs\n *   - `onRetry` when a new reconnection interval has been sent from the server\n *   - `onComment` when a comment is encountered in the stream\n *\n * @returns A new EventSource parser, with `parse` and `reset` methods.\n * @public\n */\nexport function createParser(callbacks: ParserCallbacks): EventSourceParser {\n  if (typeof callbacks === 'function') {\n    throw new TypeError(\n      '`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?',\n    )\n  }\n\n  const {onEvent = noop, onError = noop, onRetry = noop, onComment} = callbacks\n\n  let incompleteLine = ''\n\n  let isFirstChunk = true\n  let id: string | undefined\n  let data = ''\n  let eventType = ''\n\n  function feed(newChunk: string) {\n    // Strip any UTF8 byte order mark (BOM) at the start of the stream\n    const chunk = isFirstChunk ? newChunk.replace(/^\\xEF\\xBB\\xBF/, '') : newChunk\n\n    // If there was a previous incomplete line, append it to the new chunk,\n    // so we may process it together as a new (hopefully complete) chunk.\n    const [complete, incomplete] = splitLines(`${incompleteLine}${chunk}`)\n\n    for (const line of complete) {\n      parseLine(line)\n    }\n\n    incompleteLine = incomplete\n    isFirstChunk = false\n  }\n\n  function parseLine(line: string) {\n    // If the line is empty (a blank line), dispatch the event\n    if (line === '') {\n      dispatchEvent()\n      return\n    }\n\n    // If the line starts with a U+003A COLON character (:), ignore the line.\n    if (line.startsWith(':')) {\n      if (onComment) {\n        onComment(line.slice(line.startsWith(': ') ? 2 : 1))\n      }\n      return\n    }\n\n    // If the line contains a U+003A COLON character (:)\n    const fieldSeparatorIndex = line.indexOf(':')\n    if (fieldSeparatorIndex !== -1) {\n      // Collect the characters on the line before the first U+003A COLON character (:),\n      // and let `field` be that string.\n      const field = line.slice(0, fieldSeparatorIndex)\n\n      // Collect the characters on the line after the first U+003A COLON character (:),\n      // and let `value` be that string. If value starts with a U+0020 SPACE character,\n      // remove it from value.\n      const offset = line[fieldSeparatorIndex + 1] === ' ' ? 2 : 1\n      const value = line.slice(fieldSeparatorIndex + offset)\n\n      processField(field, value, line)\n      return\n    }\n\n    // Otherwise, the string is not empty but does not contain a U+003A COLON character (:)\n    // Process the field using the whole line as the field name, and an empty string as the field value.\n    // üëÜ This is according to spec. That means that a line that has the value `data` will result in\n    // a newline being added to the current `data` buffer, for instance.\n    processField(line, '', line)\n  }\n\n  function processField(field: string, value: string, line: string) {\n    // Field names must be compared literally, with no case folding performed.\n    switch (field) {\n      case 'event':\n        // Set the `event type` buffer to field value\n        eventType = value\n        break\n      case 'data':\n        // Append the field value to the `data` buffer, then append a single U+000A LINE FEED(LF)\n        // character to the `data` buffer.\n        data = `${data}${value}\\n`\n        break\n      case 'id':\n        // If the field value does not contain U+0000 NULL, then set the `ID` buffer to\n        // the field value. Otherwise, ignore the field.\n        id = value.includes('\\0') ? undefined : value\n        break\n      case 'retry':\n        // If the field value consists of only ASCII digits, then interpret the field value as an\n        // integer in base ten, and set the event stream's reconnection time to that integer.\n        // Otherwise, ignore the field.\n        if (/^\\d+$/.test(value)) {\n          onRetry(parseInt(value, 10))\n        } else {\n          onError(\n            new ParseError(`Invalid \\`retry\\` value: \"${value}\"`, {\n              type: 'invalid-retry',\n              value,\n              line,\n            }),\n          )\n        }\n        break\n      default:\n        // Otherwise, the field is ignored.\n        onError(\n          new ParseError(\n            `Unknown field \"${field.length > 20 ? `${field.slice(0, 20)}‚Ä¶` : field}\"`,\n            {type: 'unknown-field', field, value, line},\n          ),\n        )\n        break\n    }\n  }\n\n  function dispatchEvent() {\n    const shouldDispatch = data.length > 0\n    if (shouldDispatch) {\n      onEvent({\n        id,\n        event: eventType || undefined,\n        // If the data buffer's last character is a U+000A LINE FEED (LF) character,\n        // then remove the last character from the data buffer.\n        data: data.endsWith('\\n') ? data.slice(0, -1) : data,\n      })\n    }\n\n    // Reset for the next event\n    id = undefined\n    data = ''\n    eventType = ''\n  }\n\n  function reset(options: {consume?: boolean} = {}) {\n    if (incompleteLine && options.consume) {\n      parseLine(incompleteLine)\n    }\n\n    isFirstChunk = true\n    id = undefined\n    data = ''\n    eventType = ''\n    incompleteLine = ''\n  }\n\n  return {feed, reset}\n}\n\n/**\n * For the given `chunk`, split it into lines according to spec, and return any remaining incomplete line.\n *\n * @param chunk - The chunk to split into lines\n * @returns A tuple containing an array of complete lines, and any remaining incomplete line\n * @internal\n */\nfunction splitLines(chunk: string): [complete: Array<string>, incomplete: string] {\n  /**\n   * According to the spec, a line is terminated by either:\n   * - U+000D CARRIAGE RETURN U+000A LINE FEED (CRLF) character pair\n   * - a single U+000A LINE FEED(LF) character not preceded by a U+000D CARRIAGE RETURN(CR) character\n   * - a single U+000D CARRIAGE RETURN(CR) character not followed by a U+000A LINE FEED(LF) character\n   */\n  const lines: Array<string> = []\n  let incompleteLine = ''\n  let searchIndex = 0\n\n  while (searchIndex < chunk.length) {\n    // Find next line terminator\n    const crIndex = chunk.indexOf('\\r', searchIndex)\n    const lfIndex = chunk.indexOf('\\n', searchIndex)\n\n    // Determine line end\n    let lineEnd = -1\n    if (crIndex !== -1 && lfIndex !== -1) {\n      // CRLF case\n      lineEnd = Math.min(crIndex, lfIndex)\n    } else if (crIndex !== -1) {\n      lineEnd = crIndex\n    } else if (lfIndex !== -1) {\n      lineEnd = lfIndex\n    }\n\n    // Extract line if terminator found\n    if (lineEnd === -1) {\n      // No terminator found, rest is incomplete\n      incompleteLine = chunk.slice(searchIndex)\n      break\n    } else {\n      const line = chunk.slice(searchIndex, lineEnd)\n      lines.push(line)\n\n      // Move past line terminator\n      searchIndex = lineEnd + 1\n      if (chunk[searchIndex - 1] === '\\r' && chunk[searchIndex] === '\\n') {\n        searchIndex++\n      }\n    }\n  }\n\n  return [lines, incompleteLine]\n}\n","import { create } from 'zustand';\nimport { ChatMessage } from '../ChatWindow/types';\n\ninterface ChatState {\n  messages: ChatMessage[];\n  isLoading: boolean;\n  conversationId: string;\n  addMessage: (message: ChatMessage) => void;\n  setLoading: (loading: boolean) => void;\n  appendStreamingMessage: (text: string, speaker?: string, speakerDisplayName?: string) => void;\n  completeStreamingMessage: () => void;\n  setConversationId: (id: string) => void;\n  reset: () => void;\n}\n\nexport const useChatStore = create<ChatState>((set) => ({\n  messages: [],\n  isLoading: false,\n  conversationId: '',\n  \n  addMessage: (message: ChatMessage) => {\n    set((state) => ({\n      messages: [...state.messages, message]\n    }));\n  },\n  \n  setLoading: (loading: boolean) => {\n    set({ isLoading: loading });\n  },\n  \n  appendStreamingMessage: (text: string, speaker?: string, speakerDisplayName?: string) => {\n    const newMessage: ChatMessage = {\n      id: `${Date.now()}-${Math.random()}`,\n      content: text,\n      timestamp: new Date(),\n      speaker: speaker || 'assistant',\n      speakerDisplayName: speakerDisplayName || speaker || 'Assistant'\n    };\n    \n    set((state) => ({\n      messages: [...state.messages, newMessage]\n    }));\n  },\n  \n  completeStreamingMessage: () => {\n    // This function is now mainly for handling conversation ID logic\n    // No need to do anything with streaming messages since they're added immediately\n  },\n  \n  setConversationId: (id: string) => {\n    set({ conversationId: id });\n  },\n  \n  reset: () => {\n    set({\n      messages: [],\n      isLoading: false,\n      conversationId: ''\n    });\n  }\n}));\n"]}