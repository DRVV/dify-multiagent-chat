{"version":3,"sources":["../src/DifyChatComponent.tsx","../src/ChatWindow/index.tsx","#style-inject:#style-inject","../src/ChatWindow/ChatWindow.module.css","../src/components/ChatInput.tsx","../src/styles/DifyChatComponent.module.css","../src/hooks/useDifyStream.ts","../../../node_modules/eventsource-parser/src/errors.ts","../../../node_modules/eventsource-parser/src/parse.ts","../src/store/chatStore.ts"],"sourcesContent":["'use client';\n\nimport React, { useMemo } from 'react';\nimport ChatWindow from './ChatWindow';\nimport { ChatInput } from './components/ChatInput';\nimport { useDifyStream } from './hooks/useDifyStream';\nimport { useChatStore } from './store/chatStore';\nimport { DifyChatComponentProps } from './types';\nimport { SpeakerConfig } from './ChatWindow/types';\nimport './styles/DifyChatComponent.module.css';\n\nconst DifyChatComponent: React.FC<DifyChatComponentProps> = ({\n  config,\n  className = '',\n  title = 'Dify Chat'\n}) => {\n  const { \n    messages, \n    isLoading \n  } = useChatStore();\n  \n  const { sendMessage } = useDifyStream(config);\n\n  // Default speakers for user and assistant\n  const speakers: SpeakerConfig[] = useMemo(() => [\n    { id: 'user', displayName: 'You', color: '#007bff' },\n    { id: 'assistant', displayName: 'Assistant', color: '#28a745' }\n  ], []);\n\n  const handleSendMessage = async (message: string) => {\n    // Add user message immediately\n    const userMessage = {\n      id: Date.now().toString(),\n      content: message,\n      timestamp: new Date(),\n      speaker: 'user',\n      speakerDisplayName: 'You'\n    };\n    \n    useChatStore.getState().addMessage(userMessage);\n    \n    // Send to Dify\n    await sendMessage(message);\n  };\n\n  // Now just use messages directly since streaming messages are added immediately\n  const displayMessages = useMemo(() => {\n    return [...messages];\n  }, [messages]);\n\n  return (\n    <div className={`container ${className}`}>\n      <div className={`chatWindowContainer`}>\n        <ChatWindow\n          messages={displayMessages}\n          speakers={speakers}\n          title={title}\n          showTimestamps={true}\n          showSpeakers={true}\n        />\n        {isLoading && (\n          <div className=\"streamingIndicator\">\n            Assistant is thinking...\n          </div>\n        )}\n      </div>\n      \n      <ChatInput\n        onSendMessage={handleSendMessage}\n        isLoading={isLoading}\n        placeholder=\"Ask me anything...\"\n      />\n    </div>\n  );\n};\n\nexport default DifyChatComponent;\nexport type { DifyChatComponentProps, DifyConfig } from './types';\n","'use client';\n\nimport React, { useMemo } from 'react';\nimport { ChatWindowProps, ChatMessage, SpeakerConfig } from './types';\nimport './ChatWindow.module.css';\n\nconst ChatWindow: React.FC<ChatWindowProps> = ({\n  messages,\n  speakers = [],\n  onExport,\n  className = '',\n  maxHeight = '400px',\n  showTimestamps = true,\n  showSpeakers = true,\n  title = 'Chat',\n}) => {\n  // Create speaker lookup for efficient access\n  const speakerMap = useMemo(() => {\n    const map = new Map<string, SpeakerConfig>();\n    speakers.forEach(speaker => {\n      map.set(speaker.id, speaker);\n    });\n    return map;\n  }, [speakers]);\n\n  // Format timestamp\n  const formatTimestamp = (timestamp: Date) => {\n    return new Intl.DateTimeFormat('en-US', {\n      hour: '2-digit',\n      minute: '2-digit',\n      hour12: true,\n    }).format(timestamp);\n  };\n\n  // Default export handler\n  const handleExport = () => {\n    if (onExport) {\n      onExport(messages);\n    } else {\n      // Built-in export functionality\n      const exportData = messages.map(msg => ({\n        timestamp: msg.timestamp.toISOString(),\n        speaker: msg.speaker,\n        speakerDisplayName: msg.speakerDisplayName,\n        content: msg.content,\n        duration: msg.duration,\n      }));\n\n      const dataStr = JSON.stringify(exportData, null, 2);\n      const dataBlob = new Blob([dataStr], { type: 'application/json' });\n      const url = URL.createObjectURL(dataBlob);\n      \n      const link = document.createElement('a');\n      link.href = url;\n      link.download = `chat-${new Date().toISOString().split('T')[0]}.json`;\n      document.body.appendChild(link);\n      link.click();\n      document.body.removeChild(link);\n      URL.revokeObjectURL(url);\n    }\n  };\n\n  return (\n    <div className={`container ${className}`}>\n      <div className=\"header\">\n        <h3 className=\"title\">{title}</h3>\n        <button\n          onClick={handleExport}\n          className=\"exportButton\"\n          disabled={messages.length === 0}\n          title=\"Export chat as JSON\"\n        >\n          Export\n        </button>\n      </div>\n\n      <div \n        className=\"messagesContainer\"\n        style={{ maxHeight }}\n      >\n        {messages.length === 0 ? (\n          <div className=\"emptyState\">\n            <div className=\"emptyIcon\">üí¨</div>\n            <div className=\"emptyText\">No messages yet</div>\n            <div className=\"emptySubtext\">Messages will appear here when sent</div>\n          </div>\n        ) : (\n          messages.map((message) => {\n            const speaker = speakerMap.get(message.speaker);\n            const displayName = message.speakerDisplayName || speaker?.displayName || message.speaker;\n            const speakerColor = speaker?.color || '#007bff';\n\n            return (\n              <div key={message.id} className=\"messageGroup\">\n                {showSpeakers && (\n                  <div className=\"messageHeader\">\n                    <span \n                      className=\"speakerName\"\n                      style={{ color: speakerColor }}\n                    >\n                      {displayName}\n                    </span>\n                    {showTimestamps && (\n                      <span className=\"timestamp\">\n                        {formatTimestamp(message.timestamp)}\n                      </span>\n                    )}\n                  </div>\n                )}\n                <div className=\"messageContent\">\n                  {message.content}\n                </div>\n              </div>\n            );\n          })\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default ChatWindow;\nexport type { ChatWindowProps, ChatMessage, SpeakerConfig };\n","\n          export default function styleInject(css, { insertAt } = {}) {\n            if (!css || typeof document === 'undefined') return\n          \n            const head = document.head || document.getElementsByTagName('head')[0]\n            const style = document.createElement('style')\n            style.type = 'text/css'\n          \n            if (insertAt === 'top') {\n              if (head.firstChild) {\n                head.insertBefore(style, head.firstChild)\n              } else {\n                head.appendChild(style)\n              }\n            } else {\n              head.appendChild(style)\n            }\n          \n            if (style.styleSheet) {\n              style.styleSheet.cssText = css\n            } else {\n              style.appendChild(document.createTextNode(css))\n            }\n          }\n          ","import styleInject from '#style-inject';styleInject(\".container {\\n  display: flex;\\n  flex-direction: column;\\n  background: #ffffff;\\n  border: 1px solid #e1e5e9;\\n  border-radius: 8px;\\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\\n  overflow: hidden;\\n}\\n.header {\\n  display: flex;\\n  justify-content: space-between;\\n  align-items: center;\\n  padding: 12px 16px;\\n  background: #f8f9fa;\\n  border-bottom: 1px solid #e1e5e9;\\n}\\n.title {\\n  font-size: 16px;\\n  font-weight: 600;\\n  color: #495057;\\n  margin: 0;\\n}\\n.exportButton {\\n  padding: 6px 12px;\\n  background: #007bff;\\n  color: white;\\n  border: none;\\n  border-radius: 4px;\\n  font-size: 12px;\\n  cursor: pointer;\\n  transition: background-color 0.2s;\\n}\\n.exportButton:hover:not(:disabled) {\\n  background: #0056b3;\\n}\\n.exportButton:disabled {\\n  background: #6c757d;\\n  cursor: not-allowed;\\n}\\n.messagesContainer {\\n  flex: 1;\\n  overflow-y: auto;\\n  padding: 16px;\\n  display: flex;\\n  flex-direction: column;\\n  gap: 12px;\\n  max-height: 400px;\\n}\\n.messageGroup {\\n  display: flex;\\n  flex-direction: column;\\n  gap: 4px;\\n}\\n.messageHeader {\\n  display: flex;\\n  align-items: center;\\n  gap: 8px;\\n  margin-bottom: 4px;\\n}\\n.speakerName {\\n  font-weight: 600;\\n  font-size: 14px;\\n  color: #007bff;\\n}\\n.timestamp {\\n  font-size: 12px;\\n  color: #6c757d;\\n}\\n.messageContent {\\n  background: #f8f9fa;\\n  padding: 8px 12px;\\n  border-radius: 12px;\\n  font-size: 14px;\\n  line-height: 1.4;\\n  color: #212529;\\n  word-wrap: break-word;\\n  max-width: 80%;\\n}\\n.emptyState {\\n  display: flex;\\n  flex-direction: column;\\n  align-items: center;\\n  justify-content: center;\\n  padding: 40px 20px;\\n  text-align: center;\\n  color: #6c757d;\\n}\\n.emptyIcon {\\n  font-size: 48px;\\n  margin-bottom: 12px;\\n  opacity: 0.5;\\n}\\n.emptyText {\\n  font-size: 16px;\\n  margin-bottom: 4px;\\n}\\n.emptySubtext {\\n  font-size: 14px;\\n  opacity: 0.7;\\n}\\n.messagesContainer::-webkit-scrollbar {\\n  width: 6px;\\n}\\n.messagesContainer::-webkit-scrollbar-track {\\n  background: #f1f1f1;\\n  border-radius: 3px;\\n}\\n.messagesContainer::-webkit-scrollbar-thumb {\\n  background: #c1c1c1;\\n  border-radius: 3px;\\n}\\n.messagesContainer::-webkit-scrollbar-thumb:hover {\\n  background: #a8a8a8;\\n}\\n\")","'use client';\n\nimport React, { useState, KeyboardEvent } from 'react';\nimport '../styles/DifyChatComponent.module.css';\n\ninterface ChatInputProps {\n  onSendMessage: (message: string) => void;\n  isLoading: boolean;\n  placeholder?: string;\n}\n\nexport const ChatInput: React.FC<ChatInputProps> = ({ \n  onSendMessage, \n  isLoading, \n  placeholder = \"Type your message...\" \n}) => {\n  const [message, setMessage] = useState('');\n\n  const handleSend = () => {\n    if (message.trim() && !isLoading) {\n      onSendMessage(message.trim());\n      setMessage('');\n    }\n  };\n\n  const handleKeyDown = (e: KeyboardEvent<HTMLTextAreaElement>) => {\n    if (e.key === 'Enter' && !e.shiftKey) {\n      e.preventDefault();\n      handleSend();\n    }\n  };\n\n  return (\n    <div className=\"inputContainer\">\n      <div className=\"inputWrapper\">\n        <textarea\n          value={message}\n          onChange={(e) => setMessage(e.target.value)}\n          onKeyDown={handleKeyDown}\n          placeholder={placeholder}\n          className=\"messageInput\"\n          rows={1}\n          disabled={isLoading}\n        />\n        <button\n          onClick={handleSend}\n          disabled={!message.trim() || isLoading}\n          className=\"sendButton\"\n          title=\"Send message\"\n        >\n          {isLoading ? '‚è≥' : '‚û§'}\n        </button>\n      </div>\n    </div>\n  );\n};\n","import styleInject from '#style-inject';styleInject(\".container {\\n  display: flex;\\n  flex-direction: column;\\n  height: 100%;\\n  max-width: 100%;\\n  background: #ffffff;\\n  border-radius: 8px;\\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\\n  overflow: hidden;\\n}\\n.chatWindowContainer {\\n  flex: 1;\\n  overflow: hidden;\\n}\\n.inputContainer {\\n  padding: 16px;\\n  border-top: 1px solid #e0e0e0;\\n  background: #f9f9f9;\\n}\\n.inputWrapper {\\n  display: flex;\\n  gap: 8px;\\n  align-items: flex-end;\\n}\\n.messageInput {\\n  flex: 1;\\n  min-height: 20px;\\n  max-height: 120px;\\n  padding: 12px 16px;\\n  border: 1px solid #d0d0d0;\\n  border-radius: 24px;\\n  font-family: inherit;\\n  font-size: 14px;\\n  line-height: 1.4;\\n  resize: none;\\n  outline: none;\\n  transition: border-color 0.2s ease;\\n}\\n.messageInput:focus {\\n  border-color: #007bff;\\n}\\n.messageInput:disabled {\\n  background-color: #f5f5f5;\\n  cursor: not-allowed;\\n}\\n.sendButton {\\n  display: flex;\\n  align-items: center;\\n  justify-content: center;\\n  width: 48px;\\n  height: 48px;\\n  background: #007bff;\\n  color: white;\\n  border: none;\\n  border-radius: 50%;\\n  cursor: pointer;\\n  font-size: 18px;\\n  transition: background-color 0.2s ease, transform 0.1s ease;\\n}\\n.sendButton:hover:not(:disabled) {\\n  background: #0056b3;\\n  transform: scale(1.05);\\n}\\n.sendButton:disabled {\\n  background: #ccc;\\n  cursor: not-allowed;\\n  transform: none;\\n}\\n.streamingIndicator {\\n  padding: 8px 16px;\\n  background: #f0f8ff;\\n  border-left: 4px solid #007bff;\\n  margin: 8px 16px;\\n  border-radius: 4px;\\n  font-size: 14px;\\n  color: #666;\\n  font-style: italic;\\n}\\n.streamingText {\\n  color: #333;\\n  font-style: normal;\\n}\\n\")","import { useCallback } from 'react';\nimport { createParser, EventSourceMessage } from 'eventsource-parser';\nimport { DifyConfig, DifySSEEvent, DifyRequestBody } from '../types';\nimport { useChatStore } from '../store/chatStore';\n\n\nexport const useDifyStream = (config: DifyConfig) => {\n  const { \n    setLoading, \n    appendStreamingMessage,\n    completeStreamingMessage,\n    conversationId,\n    setConversationId \n  } = useChatStore();\n\n  const sendMessage = useCallback(async (message: string) => {\n    setLoading(true);\n    // No need to clear streaming message since each chunk creates a new message\n    \n    try {\n      const requestBody: DifyRequestBody = {\n        inputs: {},\n        query: message,\n        response_mode: 'streaming',\n        conversation_id: conversationId,\n        user: config.user || 'user-001'\n      };\n\n      console.log(\"[useDifyStream] Start fetching for body \", requestBody);\n\n      const response = await fetch(`${config.endpoint}/v1/chat-messages`, {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${config.apiKey}`,\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(requestBody)\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      const reader = response.body?.getReader();\n      if (!reader) {\n        throw new Error('No response body reader available');\n      }\n\n      const decoder = new TextDecoder();\n      // let streamingText = '';\n\n      const parser = createParser({\n        onEvent: (ev: EventSourceMessage) => {\n//          console.log('[useDifyStream] onEvent: ', ev);\n\n          if (true || ev.event === 'message' || ev.event === 'node_finished' || ev.event === 'message_end' || ev.event === 'workflow_started' || ev.event === 'workflow_finished') {\n            try {\n              const eventData = JSON.parse(ev.data) as DifySSEEvent;\n\n              //console.log('[useDifyStream] eventData:', eventData);\n              \n              // Handle different event types\n              switch (eventData.event) {\n                // case 'message':\n                //   if (eventData.answer) {\n                //     streamingText += eventData.answer;\n                //     updateStreamingMessage(streamingText);\n                //   }\n                //   break;\n                  \n                case 'node_finished':\n                  // Primary event type for processing completion\n                  console.log('Node finished:', eventData);\n                  if (eventData.data?.outputs?.text) {\n                    const speaker = eventData.data.title;\n                    console.log(\"Speaker: \", speaker);\n                    // Create a new message entry for each streaming chunk\n                    appendStreamingMessage(eventData.data.outputs.text, speaker, speaker);\n                  }\n                  break;\n                  \n                case 'message_end':\n                  console.log('message_end:', eventData.event, eventData);  \n                \n                  completeStreamingMessage();\n                  if (eventData.conversation_id && eventData.conversation_id !== conversationId) {\n                    setConversationId(eventData.conversation_id);\n                  }\n                  break;\n                  \n                case 'workflow_started':\n                case 'workflow_finished':\n                  console.log('Workflow event:', eventData.event, eventData);\n                  break;\n              }\n            } catch (parseError) {\n              console.log('SSE parse error:', parseError);\n            }\n          }\n        }\n      });\n\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) break;\n\n        const chunk = decoder.decode(value, { stream: true });\n        parser.feed(chunk);\n      }\n    } catch (error) {\n      console.log('Dify API error:', error);\n    } finally {\n      setLoading(false);\n    }\n  }, [config, conversationId, setLoading, appendStreamingMessage, completeStreamingMessage, setConversationId]);\n\n  return { sendMessage };\n};\n","/**\n * The type of error that occurred.\n * @public\n */\nexport type ErrorType = 'invalid-retry' | 'unknown-field'\n\n/**\n * Error thrown when encountering an issue during parsing.\n *\n * @public\n */\nexport class ParseError extends Error {\n  /**\n   * The type of error that occurred.\n   */\n  type: ErrorType\n\n  /**\n   * In the case of an unknown field encountered in the stream, this will be the field name.\n   */\n  field?: string\n\n  /**\n   * In the case of an unknown field encountered in the stream, this will be the value of the field.\n   */\n  value?: string\n\n  /**\n   * The line that caused the error, if available.\n   */\n  line?: string\n\n  constructor(\n    message: string,\n    options: {type: ErrorType; field?: string; value?: string; line?: string},\n  ) {\n    super(message)\n    this.name = 'ParseError'\n    this.type = options.type\n    this.field = options.field\n    this.value = options.value\n    this.line = options.line\n  }\n}\n","/**\n * EventSource/Server-Sent Events parser\n * @see https://html.spec.whatwg.org/multipage/server-sent-events.html\n */\nimport {ParseError} from './errors.ts'\nimport type {EventSourceParser, ParserCallbacks} from './types.ts'\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction noop(_arg: unknown) {\n  // intentional noop\n}\n\n/**\n * Creates a new EventSource parser.\n *\n * @param callbacks - Callbacks to invoke on different parsing events:\n *   - `onEvent` when a new event is parsed\n *   - `onError` when an error occurs\n *   - `onRetry` when a new reconnection interval has been sent from the server\n *   - `onComment` when a comment is encountered in the stream\n *\n * @returns A new EventSource parser, with `parse` and `reset` methods.\n * @public\n */\nexport function createParser(callbacks: ParserCallbacks): EventSourceParser {\n  if (typeof callbacks === 'function') {\n    throw new TypeError(\n      '`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?',\n    )\n  }\n\n  const {onEvent = noop, onError = noop, onRetry = noop, onComment} = callbacks\n\n  let incompleteLine = ''\n\n  let isFirstChunk = true\n  let id: string | undefined\n  let data = ''\n  let eventType = ''\n\n  function feed(newChunk: string) {\n    // Strip any UTF8 byte order mark (BOM) at the start of the stream\n    const chunk = isFirstChunk ? newChunk.replace(/^\\xEF\\xBB\\xBF/, '') : newChunk\n\n    // If there was a previous incomplete line, append it to the new chunk,\n    // so we may process it together as a new (hopefully complete) chunk.\n    const [complete, incomplete] = splitLines(`${incompleteLine}${chunk}`)\n\n    for (const line of complete) {\n      parseLine(line)\n    }\n\n    incompleteLine = incomplete\n    isFirstChunk = false\n  }\n\n  function parseLine(line: string) {\n    // If the line is empty (a blank line), dispatch the event\n    if (line === '') {\n      dispatchEvent()\n      return\n    }\n\n    // If the line starts with a U+003A COLON character (:), ignore the line.\n    if (line.startsWith(':')) {\n      if (onComment) {\n        onComment(line.slice(line.startsWith(': ') ? 2 : 1))\n      }\n      return\n    }\n\n    // If the line contains a U+003A COLON character (:)\n    const fieldSeparatorIndex = line.indexOf(':')\n    if (fieldSeparatorIndex !== -1) {\n      // Collect the characters on the line before the first U+003A COLON character (:),\n      // and let `field` be that string.\n      const field = line.slice(0, fieldSeparatorIndex)\n\n      // Collect the characters on the line after the first U+003A COLON character (:),\n      // and let `value` be that string. If value starts with a U+0020 SPACE character,\n      // remove it from value.\n      const offset = line[fieldSeparatorIndex + 1] === ' ' ? 2 : 1\n      const value = line.slice(fieldSeparatorIndex + offset)\n\n      processField(field, value, line)\n      return\n    }\n\n    // Otherwise, the string is not empty but does not contain a U+003A COLON character (:)\n    // Process the field using the whole line as the field name, and an empty string as the field value.\n    // üëÜ This is according to spec. That means that a line that has the value `data` will result in\n    // a newline being added to the current `data` buffer, for instance.\n    processField(line, '', line)\n  }\n\n  function processField(field: string, value: string, line: string) {\n    // Field names must be compared literally, with no case folding performed.\n    switch (field) {\n      case 'event':\n        // Set the `event type` buffer to field value\n        eventType = value\n        break\n      case 'data':\n        // Append the field value to the `data` buffer, then append a single U+000A LINE FEED(LF)\n        // character to the `data` buffer.\n        data = `${data}${value}\\n`\n        break\n      case 'id':\n        // If the field value does not contain U+0000 NULL, then set the `ID` buffer to\n        // the field value. Otherwise, ignore the field.\n        id = value.includes('\\0') ? undefined : value\n        break\n      case 'retry':\n        // If the field value consists of only ASCII digits, then interpret the field value as an\n        // integer in base ten, and set the event stream's reconnection time to that integer.\n        // Otherwise, ignore the field.\n        if (/^\\d+$/.test(value)) {\n          onRetry(parseInt(value, 10))\n        } else {\n          onError(\n            new ParseError(`Invalid \\`retry\\` value: \"${value}\"`, {\n              type: 'invalid-retry',\n              value,\n              line,\n            }),\n          )\n        }\n        break\n      default:\n        // Otherwise, the field is ignored.\n        onError(\n          new ParseError(\n            `Unknown field \"${field.length > 20 ? `${field.slice(0, 20)}‚Ä¶` : field}\"`,\n            {type: 'unknown-field', field, value, line},\n          ),\n        )\n        break\n    }\n  }\n\n  function dispatchEvent() {\n    const shouldDispatch = data.length > 0\n    if (shouldDispatch) {\n      onEvent({\n        id,\n        event: eventType || undefined,\n        // If the data buffer's last character is a U+000A LINE FEED (LF) character,\n        // then remove the last character from the data buffer.\n        data: data.endsWith('\\n') ? data.slice(0, -1) : data,\n      })\n    }\n\n    // Reset for the next event\n    id = undefined\n    data = ''\n    eventType = ''\n  }\n\n  function reset(options: {consume?: boolean} = {}) {\n    if (incompleteLine && options.consume) {\n      parseLine(incompleteLine)\n    }\n\n    isFirstChunk = true\n    id = undefined\n    data = ''\n    eventType = ''\n    incompleteLine = ''\n  }\n\n  return {feed, reset}\n}\n\n/**\n * For the given `chunk`, split it into lines according to spec, and return any remaining incomplete line.\n *\n * @param chunk - The chunk to split into lines\n * @returns A tuple containing an array of complete lines, and any remaining incomplete line\n * @internal\n */\nfunction splitLines(chunk: string): [complete: Array<string>, incomplete: string] {\n  /**\n   * According to the spec, a line is terminated by either:\n   * - U+000D CARRIAGE RETURN U+000A LINE FEED (CRLF) character pair\n   * - a single U+000A LINE FEED(LF) character not preceded by a U+000D CARRIAGE RETURN(CR) character\n   * - a single U+000D CARRIAGE RETURN(CR) character not followed by a U+000A LINE FEED(LF) character\n   */\n  const lines: Array<string> = []\n  let incompleteLine = ''\n  let searchIndex = 0\n\n  while (searchIndex < chunk.length) {\n    // Find next line terminator\n    const crIndex = chunk.indexOf('\\r', searchIndex)\n    const lfIndex = chunk.indexOf('\\n', searchIndex)\n\n    // Determine line end\n    let lineEnd = -1\n    if (crIndex !== -1 && lfIndex !== -1) {\n      // CRLF case\n      lineEnd = Math.min(crIndex, lfIndex)\n    } else if (crIndex !== -1) {\n      lineEnd = crIndex\n    } else if (lfIndex !== -1) {\n      lineEnd = lfIndex\n    }\n\n    // Extract line if terminator found\n    if (lineEnd === -1) {\n      // No terminator found, rest is incomplete\n      incompleteLine = chunk.slice(searchIndex)\n      break\n    } else {\n      const line = chunk.slice(searchIndex, lineEnd)\n      lines.push(line)\n\n      // Move past line terminator\n      searchIndex = lineEnd + 1\n      if (chunk[searchIndex - 1] === '\\r' && chunk[searchIndex] === '\\n') {\n        searchIndex++\n      }\n    }\n  }\n\n  return [lines, incompleteLine]\n}\n","import { create } from 'zustand';\nimport { ChatMessage } from '../ChatWindow/types';\n\ninterface ChatState {\n  messages: ChatMessage[];\n  isLoading: boolean;\n  conversationId: string;\n  addMessage: (message: ChatMessage) => void;\n  setLoading: (loading: boolean) => void;\n  appendStreamingMessage: (text: string, speaker?: string, speakerDisplayName?: string) => void;\n  completeStreamingMessage: () => void;\n  setConversationId: (id: string) => void;\n  reset: () => void;\n}\n\nexport const useChatStore = create<ChatState>((set) => ({\n  messages: [],\n  isLoading: false,\n  conversationId: '',\n  \n  addMessage: (message: ChatMessage) => {\n    set((state) => ({\n      messages: [...state.messages, message]\n    }));\n  },\n  \n  setLoading: (loading: boolean) => {\n    set({ isLoading: loading });\n  },\n  \n  appendStreamingMessage: (text: string, speaker?: string, speakerDisplayName?: string) => {\n    const newMessage: ChatMessage = {\n      id: `${Date.now()}-${Math.random()}`,\n      content: text,\n      timestamp: new Date(),\n      speaker: speaker || 'assistant',\n      speakerDisplayName: speakerDisplayName || speaker || 'Assistant'\n    };\n    \n    set((state) => ({\n      messages: [...state.messages, newMessage]\n    }));\n  },\n  \n  completeStreamingMessage: () => {\n    // This function is now mainly for handling conversation ID logic\n    // No need to do anything with streaming messages since they're added immediately\n  },\n  \n  setConversationId: (id: string) => {\n    set({ conversationId: id });\n  },\n  \n  reset: () => {\n    set({\n      messages: [],\n      isLoading: false,\n      conversationId: ''\n    });\n  }\n}));\n"],"mappings":"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","names":["useMemo","jsx","jsxs","jsx","jsxs","useMemo"]}